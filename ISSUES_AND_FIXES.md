# OmniZen Application Issues & Fix Plan
*Comprehensive Analysis and Atomic Fix List*

## üìä Executive Summary

The OmniZen application has **15 critical issues** across 4 major areas:
- **Database Schema & Queries** (6 issues)
- **Authentication System** (2 issues)  
- **Redis & AI Agents** (3 issues)
- **Migration & Code Quality** (4 issues)

All issues are **atomic and self-contained** - each can be fixed independently with clear root causes and evidence-based solutions.

---

## üîç Database Schema & Query Issues

### Issue #1: Missing Database Columns
- **Problem**: Queries reference non-existent columns like `contact_id`, `org_id`, `account_code`, `product_name`
- **Root Cause**: Schema definitions don't match the actual queries being generated by AI agents and business logic
- **Evidence**: 
  - `debug.log:75` - "column i.contact_id does not exist"
  - `server.log:88` - "column org_id does not exist"
  - `server.log:634` - "column p.product_name does not exist"
- **Solution**: 
  1. Audit all schema files in `/lib/db/schema/` directory
  2. Compare with actual query usage in AI agents and business logic
  3. Add missing columns or rename existing ones for consistency
  4. Update TypeScript types to match
- **Why Solution is Correct**: The schema exports in `/lib/db/schema/index.ts` show proper organization structure, but individual schema files need column name consistency with actual usage patterns
- **Status**: [ ] Not Started

### Issue #2: SQL Syntax Errors in Generated Queries
- **Problem**: Malformed SQL queries with syntax errors near "WHERE", "LIMIT", "GROUP BY", "ORDER BY"
- **Root Cause**: Query builder logic in AI database tools generating invalid SQL syntax
- **Evidence**: Hundreds of instances in logs:
  - `debug.log:47` - "syntax error at or near WHERE"
  - `debug.log:163` - "syntax error at or near LIMIT" 
  - `debug.log:705` - "syntax error at or near GROUP"
- **Solution**:
  1. Review AI database tool query generation logic
  2. Fix SQL clause ordering and syntax validation
  3. Add query validation before execution
  4. Test all query patterns used by AI agents
- **Why Solution is Correct**: Valid SQL requires proper clause ordering (SELECT, FROM, WHERE, GROUP BY, ORDER BY, LIMIT) - these are fundamental SQL grammar violations that need systematic fixing
- **Status**: [ ] Not Started

### Issue #3: Missing Semantic Views
- **Problem**: Database views like `v_profit_loss_statement`, `v_customer_revenue`, `v_kpi_dashboard` don't exist
- **Root Cause**: Supabase migrations for semantic views haven't been applied or are incomplete
- **Evidence**: 
  - `debug.log:203` - "relation v_profit_loss_statement does not exist"
  - `debug.log:658` - "relation v_profit_loss_statement does not exist"
  - `debug.log:671` - "relation v_customer_revenue does not exist"
  - `debug.log:684` - "relation v_kpi_dashboard does not exist"
- **Solution**:
  1. Verify Supabase migration `/supabase/migrations/20250904030000_semantic_views.sql` exists
  2. Run `pnpm supabase:migrate:local` to apply semantic views
  3. Test that all 10 semantic views are created successfully
- **Why Solution is Correct**: The migration file exists in the supabase/migrations directory, indicating views were designed but not applied. These views are critical for AI agent financial reporting functionality.
- **Status**: [ ] Not Started

### Issue #4: Column Reference Ambiguity in JOINs
- **Problem**: "column reference organization_id is ambiguous" errors in JOIN queries
- **Root Cause**: Multiple tables have same column names without proper table aliases in JOIN operations
- **Evidence**: Multiple instances in logs:
  - `server.log:261` - "column reference organization_id is ambiguous"
  - `server.log:272` - "column reference organization_id is ambiguous"
- **Solution**:
  1. Add explicit table aliases in all JOIN queries
  2. Qualify all column references with table aliases
  3. Review query generation to ensure proper aliasing
- **Why Solution is Correct**: SQL standard requires disambiguation when multiple tables contain same column names. The schema shows multiple tables with `organization_id` columns that need proper aliasing.
- **Status**: [ ] Not Started

### Issue #5: Invalid UUID Type Casting
- **Problem**: Attempting to use string literals like "org_123" and "default" as UUIDs
- **Root Cause**: Test data or default values using invalid UUID format instead of proper UUID strings
- **Evidence**: 
  - `debug.log:1641` - "invalid input syntax for type uuid: org_123"
  - `server.log:441` - "invalid input syntax for type uuid: default"
- **Solution**:
  1. Find all hardcoded string values used as UUIDs
  2. Replace with proper UUID format or NULL values
  3. Update test data to use valid UUIDs
  4. Add UUID validation in input handling
- **Why Solution is Correct**: PostgreSQL UUID type requires RFC 4122 format. The schema definitions show UUID types that must receive properly formatted UUID strings.
- **Status**: [ ] Not Started

### Issue #6: Invalid Enum Values
- **Problem**: Trying to insert "revenue" into account_type enum that doesn't include this value
- **Root Cause**: Schema enum definition doesn't match expected business logic values
- **Evidence**: 
  - `debug.log:1008` - "invalid input value for enum account_type: revenue"
- **Solution**:
  1. Review enum definitions in schema files
  2. Either add "revenue" to account_type enum or change business logic
  3. Ensure all enum values match business requirements
  4. Update migration to include all required enum values
- **Why Solution is Correct**: PostgreSQL enums are strict - only predefined values are allowed. The business logic expects "revenue" as a valid account type, so enum must include it.
- **Status**: [ ] Not Started

---

## üîê Authentication System Issues

### Issue #7: Auth Bridge Implementation Gaps
- **Problem**: Authentication bridge between NextAuth and Supabase may have integration issues
- **Root Cause**: Complex dual-auth system requires careful synchronization between two authentication systems
- **Evidence**: 
  - Auth bridge code exists in `/lib/auth/auth-bridge.ts`
  - Database errors suggest RLS context may not be set properly
  - JWT generation and validation may have issues
- **Solution**:
  1. Test auth bridge end-to-end with real authentication flows
  2. Verify JWT token generation includes all required claims
  3. Test RLS context setting and verification functions
  4. Ensure proper error handling in auth failures
- **Why Solution is Correct**: Dual auth system documented in CLAUDE.md requires both NextAuth and Supabase to be perfectly synchronized. The auth bridge is the critical component ensuring this synchronization.
- **Status**: [ ] Not Started

### Issue #8: RLS Context Functions Missing/Broken
- **Problem**: RLS helper functions like `auth_org_id()`, `auth_user_id()`, `auth_workspace_id()`, `auth_role()` may not exist or work properly
- **Root Cause**: Supabase migrations for auth functions may not have been applied correctly
- **Evidence**: 
  - Auth bridge code calls these functions but database errors suggest they're missing
  - RLS policies depend on these functions but may fail silently
- **Solution**:
  1. Verify migration `/supabase/migrations/20250902074337_auth_functions.sql` was applied
  2. Test each auth helper function manually in database
  3. Fix any issues with function implementation
  4. Test RLS policies that depend on these functions
- **Why Solution is Correct**: RLS policies documented in CLAUDE.md depend on these helper functions. They're core to the security model and must work correctly for multi-tenant data isolation.
- **Status**: [ ] Not Started

---

## üß† Redis & AI Agent Issues

### Issue #9: Redis Connection Failures
- **Problem**: Redis client connection and initialization issues preventing AI agent memory system from working
- **Root Cause**: Redis URL configuration, connection handling, or Redis server availability problems
- **Evidence**: 
  - Query memory system references in code but connection issues apparent
  - AI agent memory system depends on Redis but may be failing silently
- **Solution**:
  1. Verify Redis connection configuration in environment variables
  2. Fix Redis client initialization in `/lib/ai/query-memory.ts`
  3. Add proper error handling and retry logic
  4. Test Redis connection and basic operations
- **Why Solution is Correct**: Redis is documented as critical for AI agent memory system. The code in `/lib/ai/query-memory.ts` shows Redis integration but needs robust connection handling.
- **Status**: [ ] Not Started

### Issue #10: AI Function Schema Validation Errors
- **Problem**: Invalid schemas for AI tools causing API call failures
- **Root Cause**: Function schemas don't conform to JSON Schema requirements for AI SDK
- **Evidence**: 
  - `server.log:42` - "Invalid schema for function 'dbRead': schema must be a JSON Schema of 'type: object', got 'type: null'"
- **Solution**:
  1. Review all AI tool function schemas
  2. Fix schema definitions to be valid JSON Schema objects
  3. Ensure all required properties are properly defined
  4. Test AI function calling with corrected schemas
- **Why Solution is Correct**: AI SDK requires valid JSON Schema for function calling. Type safety is essential for reliable AI agent operation.
- **Status**: [ ] Not Started

### Issue #11: Query Memory Capture Type Errors
- **Problem**: TypeError in query memory system when processing outputs
- **Root Cause**: Code assumes `output` is string but may be different type (object, null, undefined)
- **Evidence**: 
  - `debug.log:549` - "TypeError: output.includes is not a function"
  - Line 400 in query memory code: `const isSuccess = output && !output.includes('[Error') && !output.includes('Error:')`
- **Solution**:
  1. Add proper type checking before calling string methods on `output` variable
  2. Handle cases where output is not a string
  3. Add null/undefined checks
  4. Test with various output types
- **Why Solution is Correct**: TypeScript strict mode requires proper type handling. The error shows runtime type assumption failure that needs defensive programming.
- **Status**: [ ] Not Started

---

## üèóÔ∏è Migration System Issues

### Issue #12: Migration Order Dependencies
- **Problem**: Drizzle and Supabase migrations may not run in correct order, causing dependency failures
- **Root Cause**: Dual migration system without proper coordination between table creation and RLS/view setup
- **Evidence**: 
  - Views fail because tables don't exist
  - Functions fail because schemas missing
  - Migration script shows proper order but execution may be inconsistent
- **Solution**:
  1. Ensure migration scripts always run Drizzle first (tables), then Supabase (RLS/views)
  2. Add dependency checking in migration scripts
  3. Test complete migration reset and rebuild
  4. Document proper migration order in scripts
- **Why Solution is Correct**: The `/lib/db/migrate.ts` shows understanding of proper order, but the dual system needs foolproof coordination. CLAUDE.md documents the separation clearly.
- **Status**: [ ] Not Started

### Issue #13: Search Path Configuration
- **Problem**: Database search path not set correctly for multi-schema setup
- **Root Cause**: Queries fail to find tables in different schemas (public, core, finance, ai, semantic)
- **Evidence**: 
  - Migration script sets search path but runtime queries may not inherit it
  - Schema organization shows multi-schema design
- **Solution**:
  1. Ensure all database connections use proper search path configuration
  2. Set search path in connection initialization
  3. Test that all schemas are accessible in queries
  4. Document search path requirements
- **Why Solution is Correct**: Multi-schema setup documented in CLAUDE.md requires explicit search path. The migrate.ts shows awareness but runtime connections need same configuration.
- **Status**: [ ] Not Started

### Issue #14: Missing Error Boundaries
- **Problem**: Database errors cascade without proper error handling, causing poor user experience
- **Root Cause**: No consistent error handling strategy across database operations and UI components
- **Evidence**: 
  - Errors logged extensively but not gracefully handled in UI
  - Database failures cause system-wide issues
- **Solution**:
  1. Implement proper error boundaries in React components
  2. Add fallback mechanisms for database failures
  3. Create consistent error handling patterns
  4. Test error scenarios and recovery
- **Why Solution is Correct**: Robust applications need graceful error handling to prevent user-facing crashes. The extensive error logging shows issues occur but aren't handled gracefully.
- **Status**: [ ] Not Started

### Issue #15: TypeScript Type Inconsistencies
- **Problem**: Type mismatches between schema definitions and actual usage
- **Root Cause**: Schema types don't match actual database column types or business logic expectations
- **Evidence**: 
  - Runtime type errors suggest schema/reality mismatch
  - Column name mismatches indicate type definition issues
- **Solution**:
  1. Regenerate types with `pnpm db:types`
  2. Fix any inconsistencies between schema and usage
  3. Update business logic to match type definitions
  4. Add type validation at runtime boundaries
- **Why Solution is Correct**: Type safety prevents runtime errors - core benefit of TypeScript. The schema structure suggests types exist but may be outdated or inconsistent.
- **Status**: [ ] Not Started

---

## üéØ Priority Matrix

### Critical (Fix First)
- **Issue #1**: Missing Database Columns
- **Issue #2**: SQL Syntax Errors  
- **Issue #3**: Missing Semantic Views
- **Issue #12**: Migration Order Dependencies

### High Priority
- **Issue #7**: Auth Bridge Implementation
- **Issue #8**: RLS Context Functions
- **Issue #4**: Column Reference Ambiguity
- **Issue #13**: Search Path Configuration

### Medium Priority
- **Issue #9**: Redis Connection Failures
- **Issue #10**: AI Function Schema Validation
- **Issue #5**: Invalid UUID Type Casting
- **Issue #6**: Invalid Enum Values

### Low Priority  
- **Issue #11**: Query Memory Capture Type Errors
- **Issue #14**: Missing Error Boundaries
- **Issue #15**: TypeScript Type Inconsistencies

---

## üìã Implementation Checklist

Each issue can be tracked independently:

- [ ] **Issue #1**: Missing Database Columns
- [ ] **Issue #2**: SQL Syntax Errors in Generated Queries  
- [ ] **Issue #3**: Missing Semantic Views
- [ ] **Issue #4**: Column Reference Ambiguity in JOINs
- [ ] **Issue #5**: Invalid UUID Type Casting
- [ ] **Issue #6**: Invalid Enum Values
- [ ] **Issue #7**: Auth Bridge Implementation Gaps
- [ ] **Issue #8**: RLS Context Functions Missing/Broken
- [ ] **Issue #9**: Redis Connection Failures
- [ ] **Issue #10**: AI Function Schema Validation Errors
- [ ] **Issue #11**: Query Memory Capture Type Errors
- [ ] **Issue #12**: Migration Order Dependencies
- [ ] **Issue #13**: Search Path Configuration
- [ ] **Issue #14**: Missing Error Boundaries
- [ ] **Issue #15**: TypeScript Type Inconsistencies

---

## üî¨ Testing Strategy

For each issue fix:
1. **Unit Test**: Test the specific component in isolation
2. **Integration Test**: Test with related systems
3. **End-to-End Test**: Test full user workflows
4. **Regression Test**: Ensure fix doesn't break other functionality

---

## üìù Common Commands for Fixes

```bash
# Database Operations
pnpm db:generate          # Generate new migrations
pnpm db:migrate           # Run Drizzle migrations
pnpm supabase:migrate:local # Run Supabase migrations
pnpm migrate:local        # Run both migration systems
pnpm db:reset:local       # Reset and rebuild database

# Development
pnpm dev                  # Start development server
pnpm build                # Build application
pnpm lint                 # Run linting
pnpm format              # Format code

# Testing
pnpm test                # Run tests
npx tsx scripts/verify-dual-auth.ts  # Verify auth system
```

---

## üìö Key Files for Reference

- **Database Schema**: `/lib/db/schema/index.ts` and subdirectories
- **Migrations**: `/lib/db/migrations/` and `/supabase/migrations/`
- **Auth Bridge**: `/lib/auth/auth-bridge.ts`
- **AI Agents**: `/lib/ai/` directory
- **Project Config**: `CLAUDE.md` for project-specific instructions

---

*This comprehensive plan provides atomic, evidence-based fixes for all identified issues in the OmniZen application. Each issue can be addressed independently with clear success criteria and testing approaches.*